# HSEA课程作业一: Pacoban游戏
## 文件概述
* 采用[GVG-AI](http://www.gvgai.net/)游戏框架
* `src.tracks.multiPlayer`中有各种控制器
    * 自行设计的启发式搜索方法在`src.tracks.multiPlayer.myController`中
## 任务
* 自行设计启发式搜索方法, 使得最后两个玩家能获得的总分最高 

## 文件及运行方式说明
&emsp;&emsp;实现的启发式搜索controller在路径 `src/tracks/multiplayer/myController/heuristicSearch/` 目录下, 
分为 `Agent.java` 与 `MyHeuristic.java` 两个文件. 前者是实现控制的主程序, 后者中实现了启发式函数. 枚举类 `Itype` 记录的
是各种道具的编号信息.  
&emsp;&emsp;在测试时, 固定种子 `2020` , `TIME_CONSTRAINED` 设置为 `true` , `ACTION_TIME` 设置为 `50`, 
每个关卡运行 `10` 遍, 取两个玩家得分和的平均值.
## 对游戏的理解
&emsp;&emsp;该游戏需要控制吃豆人在避开幽灵的追击的情况下去吃下道具来获得分数. 能吃的道具有三种: 豆子, 水果和宝石. 吃下豆子能获得1分, 吃下1个水果得5分, 吃下1个宝石得10分, 同时在吃下宝石后, 在200个 timestemp 内处于强化状态, 此时可以去击杀幽灵, 击杀1次幽灵可以得40分 (幽灵被击杀后不会消失, 所以按次击杀). 以上三种道具, 最多的是豆子, 水果和宝石一般都是4个. 所以该游戏的目标比较明确, 首先保证吃到豆子, 然后来到水果和宝石附近时把水果和宝石吃掉, 吃掉宝石后, 根据情况选择是否击杀幽灵.   
&emsp;&emsp;再观察个各种道具的分布, 豆子大多数呈一行或一列分布, 这意味着在不考虑幽灵追击的情况下, 高效吃豆的方式是来到一行 (一列) 的开始然后按照一个方向吃下去. 宝石分布在最外层4个角, 水果也分布在四角, 不过相对宝石在内层.   
&emsp;&emsp;至于幽灵的行为, 在多次游戏中发现他们的移动模式并不是很固定, 有时4个幽灵一起行动扑向一个吃豆人, 有时某几个幽灵突然会静止不动, 不过大多数时候都是在试图接近两个吃豆人. 当有一个吃豆人吃下宝石后, 幽灵可以被击杀, 此时他们会尽量远离吃豆人. 利用砖块封堵幽灵不是主要游戏目标, 毕竟封堵幽灵并不会得分, 在局面合适的情况下可以选择去封堵幽灵.   
&emsp;&emsp;同时也要注意到不同于有固定目标位置找最短路径的问题, 游戏的局面每时每刻都在变化, 两个吃豆人加上四个幽灵可能的移动方式太多了, 如果进行多层搜索的开销太大并且可能在搜索时局面已经发生了变化, 所以在搜索时采用 ”一步一搜”.  

## 算法设计
### `Agent` 的设计
&emsp;&emsp;注意到这是个双人游戏, 所以在搜索时要为另一个吃豆人指定动作. 这个动作由 `getOppNotLosing()` 方法实现, 它会从所有不会导致游戏结束的动作中随机选择一个返回. 在此做出的一个假设是二号玩家一直都在运动中, 所以不会返回 Types.ACTIONS.ACTION_NIL.   
&emsp;&emsp;对于受控的吃豆人, 评估在当前位置上分别执行每个可执行动作后导致的新局面的情况, 评估得分调用启发式函数 ( `MyHeuristic` 类中的 `evaluateState()` 方法) 得到. 得分最大者作为最终选择的动作. 当多个动作都是最大评估值时, 随机选取一个返回.   
&emsp;&emsp;在 `Agent` 类中还有一些调试时用来打印信息的方法.  

### `MyHeuristic` 的设计
&emsp;&emsp;评估功能由 `evaluateState()` 方法实现. 初始化一个 `MyHeuristic` 类的对象时, 传入的参数是当前位置的局面信息 (`stateObs`) 的对象, 用来初始化变量 `originStateObs` . 而向 `evaluateState()` 方法传入的是 `originStateObs` 执行了某个动作后的新局面以及当前受控对象的ID (`playerID`). 评估值 `value` 由以下几个部分组成  
&emsp;&emsp;`curActGain`: 执行当前动作的收益  
&emsp;&emsp;`backPosGain`: 来回横跳的收益. 如果执行动作后变成了在两个格子间来回横跳, 那么加上一个负值  
&emsp;&emsp;`ghostAlertGain`, `ghostCloseGain`: 前者当幽灵离新位置在一定距离 (称为警告距离) 时, 加上一个负值; 后者当幽灵非常接近新位置 (称为危险距离) 时, 加上一个更小的负值. 这两个距离都用曼哈顿距离度量, 警告距离和危险距离需要手动指定, 比如警报距离设置为5, 危险距离设置为3.  
&emsp;&emsp;三种道具的`AroundGain`和`AheadGain`: `AroundGain`是通过搜索新位置一周8个格子上道具的数量来确定的; `AheadGain`反应了按照当前朝向, 手动指定的几个格子内道具的数量, 这源于对游戏中道具分布情况的观察.  
&emsp;&emsp;以上的几个部分在满足情况时得到的收益的具体数值, 都在枚举类型 `ExpectScore`中指定. 最后将这几个部分汇总得到 `value` 的值并且返回. 此外, 如果遇到执行动作后停留在原地的情况, 即遇到双层及以上的墙块的时候, 直接返回一个很小的负值, 那么这个动作就不会被选定为当前状态下的最佳动作.   

## 效果评估
&emsp;&emsp;采用以上的启发式函数, TIME_CONSTRAINED 设置为 true, ACTION_TIME 设置为50, 在每个关卡上运行十次, 两个玩家的平均得分之和如下表所示.
    
|关卡|一号玩家得分|二号玩家得分|总得分|  
|---|---|---|---|  
|0|	69.1|	95.2|	164.3|  
|1|	89.9|	102.5|	192.4|  
|2|	95.3|	95.6|	190.9| 
|3|	44.6|	44.1|	88.7|  
|4|	71.0|	58.2|	129.2|  

## 算法改进
&emsp;&emsp;注意到在上面的算法中, 仅仅将宝石作为一种得分道具, 而忽略了吃下宝石后在200个 timestep 内能够击杀幽灵的特性. 在手动操控时, 由于延迟导致击杀幽灵并不是那么容易, 但是直接调用 controller 来控制, 那么可以更为容易地击杀幽灵, 不仅如此, 还可以考虑在强化状态下多次击杀幽灵来获得更高的分数. 因此, 当吃豆人吃到宝石后, 策略就发生改变, 此时应该主动追击幽灵来得分, 而吃豆就不是目前的主要目标了.   
&emsp;&emsp;由于有4个幽灵, 2个吃豆人, 所以可以让每个吃豆人追击固定的两个幽灵, 这样可以在幽灵较为分散的时候同时打击. 此外, 由于强化状态只能持续 200 个 timestemp , 所以要在切换回饥饿状态前的一段时间远离幽灵, 得到下一次攻击的机会.   
&emsp;&emsp;按照以上思路, 对 Agent 和 MyHeuristic 进行修改. 在 MyHeuristic 中创建一个evaluateStaeteAdvanced() 方法. 在 Agent 中检测到当前是强化状态时, 调用evaluateStaeteAdvanced() 方法来作为启发式函数.     
&emsp;&emsp;采用以上的启发式函数, TIME_CONSTRAINED 设置为 true, ACTION_TIME 设置为50, 在每个关卡上运行十次, 两个玩家的平均得分之和如下表所示.  



|关卡|	一号玩家得分|	二号玩家得分| 总得分|
|---|---|---|---|
|0|	1283.2|	2040.6|	3323.8|
|1|	1961.2|	3847.1|	5808.3|
|2|	1391.9|	2241.3|	3633.2|
|3|	1514.5|	158.1|	1672.6|
|4|	1398.1|	2846.3|	4244.4|

&emsp;&emsp;可以看出, 不断击杀幽灵会带来极其显著的得分提升. 但是要注意到的是, 由于长时间反复击杀一个幽灵, 会使得其他幽灵聚拢过来, 所以最后并不是很容易逃脱, 否则要花费更多的开销提前判断. 因此得分几乎取决于强化状态内反复击杀的时长.  
